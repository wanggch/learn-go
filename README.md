# learn-go

Go 学习系列配套示例代码，按文章编号分目录存放。

## 目录结构

- `series/01`：第 1 篇文章 + 示例代码
- `series/02`：第 2 篇文章 + 示例代码
- `series/03`：第 3 篇文章 + 示例代码
- `series/04`：第 4 篇文章 + 示例代码
- `series/05` ~ `series/40`：后续文章目录

## 运行示例

```bash
# 第 1 篇示例
go run ./series/01/cmd/hello -name="小明" -lang=go

# 第 2 篇示例
go run ./series/02/cmd/cli -name="小明" -lang=go

# 第 3 篇示例
go run ./series/03/cmd/app -app="deploy-bot" -owner="平台组"

# 第 4 篇示例
go run ./series/04/cmd/zero -service="order-gateway" -timeout=2s -retry=3 -debug=true
```

## 测试

```bash
go test ./series/01/...
go test ./series/02/...
go test ./series/03/...
go test ./series/04/...
```

---

## 📚 系列文章总览

《Go 语言学习系列》是一套以实战为导向的 Go 语言教程，共 40 篇文章。与传统教程不同，本系列采用"场景复现 → 问题分析 → 代码实战"的模式，每篇文章都从一个真实的线上问题或开发痛点出发，带你理解 Go 语言的核心特性和最佳实践。

系列前半部分（第 1-20 篇）聚焦 Go 语言基础：项目结构、错误处理、控制流、数据结构（slice/map）、函数与方法、接口设计、指针与内存、并发原语（goroutine/channel/mutex）等。每个知识点都配有可运行的示例代码，让你在动手实践中掌握 Go 的核心概念。

后半部分（第 21-40 篇）深入实战场景：channel 的正确用法、select 多路复用、goroutine 泄漏排查、context 超时控制、并发模式（worker pool）、atomic 与 mutex 的边界、bufio 性能优化、HTTP 客户端/服务端开发、标准库实战、结构化日志、pprof 性能分析、项目结构设计、错误可观测性，直到最后的综合实战项目。

本系列特别强调"避坑"——那些让你凌晨三点被告警叫醒的 Bug：nil 接口的双层结构、slice 共享底层数组、goroutine 泄漏、数据竞争、超时配置不当……这些问题在文章中都有详细的复现和解决方案。无论你是 Go 新手还是有经验的开发者，这套教程都能帮你写出更健壮、更高效的 Go 代码。

---

## 📖 章节目录与简介

### 第 1 篇：Go 项目结构入门
Go 项目应该长什么样？本篇通过一个 50 行代码的 Demo，展示 `cmd/`、`internal/` 的经典目录布局。讲解 flag 包的命令行参数解析、map 与 comma ok 惯用法、包的可见性规则，帮你建立标准 Go 项目的第一印象。

### 第 2 篇：程序入口与参数解析
程序启动就报错？本篇讲解如何将参数解析逻辑抽离到独立包，让 main 函数保持极简。涵盖多返回值、结构体封装配置、internal 包的访问控制、表驱动测试等 Go 开发的"标准起手式"。

### 第 3 篇：代码组织与包管理
代码全堆在根目录？本篇演示 `cmd/internal/pkg` 三层结构如何划分清晰的代码边界。讲解 Go 的"一个目录即一个包"规则、internal 目录的访问控制特性，从源头避免"代码屎山"。

### 第 4 篇：零值与配置覆盖
用户没传参数，程序却把零值当成有效配置？本篇通过配置管理场景，讲解 Go 的零值设计哲学。展示如何用"零值感知"的覆盖策略，把"语言零值"和"业务默认值"清晰分离。

### 第 5 篇：控制流实战
if/else 嵌套成山？本篇通过任务调度场景，演示 Go 控制流的"平铺式"写法：if 守卫式提前返回、for 重试循环、switch 多分支调度、带标签的 break。让代码保持扁平、可读、易调试。

### 第 6 篇：Slice 与 Map 避坑指南
线上那个"偶发"的 Bug，原来是 slice 和 map 在作怪。本篇通过 5 个演示函数，讲解 nil map 初始化、三索引切片控制共享、make 预分配、排序 keys 稳定遍历等核心技巧，理解 slice 的"指针+len+cap"三元组结构。

### 第 7 篇：多返回值与错误处理
那个"少扣钱"的 Bug，让我重新理解了 Go 的错误处理。本篇展示 `(value, error)`、`(value, ok)`、`(v1, v2, error)`、`(cleanup, error)` 四种多返回值模式，以及用 `%w` 实现错误链包装。

### 第 8 篇：方法与接收者
那个"修改不生效"的 Bug，让我搞懂了值接收者和指针接收者。本篇通过工单处理场景，讲解方法集决定接口适配、嵌入实现方法提升、构造函数模式 `NewXxx() (*T, error)`。

### 第 9 篇：接口设计原则
那个 12 个方法的"大接口"，让我重新理解了 Go 的接口设计。本篇展示最小接口（1-3 个方法）、消费者定义接口、函数类型适配器三个核心原则，理解 Go 隐式实现的设计哲学。

### 第 10 篇：接口与 nil 的陷阱
那个"不为 nil 却 panic"的 Bug，让我搞懂了 Go 接口的双层结构。本篇通过 5 个场景演示 typed nil 问题，讲解接口值的"动态类型 + 动态值"组成，以及安全工厂、防御性编程等解决方案。

### 第 11 篇：defer/panic/recover
凌晨三点的 panic 告警，让我彻底搞懂了 defer/panic/recover。本篇讲解 Go 异常处理三件套的正确打开方式，讨论何时用 panic、何时返回 error，以及 recover 的使用边界。

### 第 12 篇：组合优于继承
告别"继承地狱"：Go 的组合模式让我的代码清晰了 10 倍。本篇展示如何用"组合 + 方法提升"替代继承，实现日志、指标、校验等通用逻辑的复用，让代码更灵活、更易维护。

### 第 13 篇：指针使用指南
那个"修改不生效"的 Bug，让我彻底搞懂了 Go 的指针。本篇讲解什么时候用值、什么时候用指针的决策框架，帮你建立清晰的指针使用心智模型。

### 第 14 篇：逃逸分析
那个"内存飙升"的问题，让我搞懂了 Go 的逃逸分析。本篇讲解变量什么时候在栈、什么时候在堆，破除"用指针就会逃逸"的误解，理解编译器如何根据变量生命周期做决策。

### 第 15 篇：GC 原理与调优
那个"延迟尖刺"的问题，让我搞懂了 Go 的 GC。本篇通过不同 GOGC 设置对比 GC 行为，讲解 runtime.MemStats、debug.SetGCPercent、gctrace 的使用，让 GC 问题"有据可查"。

### 第 16 篇：GC 友好的代码
服务 p99 延迟飙升？可能是你的 Go 代码分配太多了。本篇通过 8 种写法对比，展示如何写出对 GC 友好的代码，减少不必要的内存分配。

### 第 17 篇：字符串深入浅出
那个"用户昵称乱码"的 Bug，让我搞懂了 Go 的字符串。本篇讲解 string、[]byte、rune 的关系，解释为什么 `len("你好")` 等于 6，掌握字符串处理的正确姿势。

### 第 18 篇：Time 包完全指南
那个"订单时间差 8 小时"的 Bug，让我搞懂了 Go 的时区处理。本篇通过五个场景演示 time 包核心用法：Duration 单位换算、Parse vs ParseInLocation 时区差异、Timer 超时控制、Ticker 周期任务、Round/Truncate 时间对齐。

### 第 19 篇：Goroutine 并发控制
那个"内存暴涨"的事故，让我搞懂了 goroutine 不是免费的。本篇讲解如何从无限制到有限制、从泄露到优雅退出，掌握并发控制的核心技巧。

### 第 20 篇：数据竞争与 Mutex
那个"计数少了几万"的 Bug，让我搞懂了 Go 的数据竞争。本篇通过有锁/无锁对比，讲解临界区概念、sync.Mutex 的正确用法、race detector 的使用。

### 第 21 篇：Channel 核心用法
别再把 channel 当锁用了！本篇通过四个演示，帮你理解 channel 的本质：它既是通信管道，也是同步原语。分清"传数据"和"协调时序"两种用途。

### 第 22 篇：Select 多路复用
线上 goroutine 卡死？因为你没用好 select。本篇通过五个 Demo 展示 select 如何把"等待"变成可控的：超时、非阻塞、多路复用、取消传播、动态禁用分支。

### 第 23 篇：Goroutine 泄漏排查
服务跑着跑着就卡了？90% 是 goroutine 泄漏。本篇用三组对照实验（leak vs fix），直观展示 recv/send/ticker 三大泄漏元凶的成因和修复方法。

### 第 24 篇：Context 完全指南
上游超时了下游还在跑？因为你没用好 Go 的 context。本篇讲解如何用 context 统一取消、超时、元数据传递，让上游能控制下游。

### 第 25 篇：并发模式实战
Go 并发代码总是"乱"？这套 worker pool 模板帮你收口。本篇实现完整的 worker pool + fan-out + fan-in + context 模式，形成可复用的并发骨架。

### 第 26 篇：Atomic vs Mutex
atomic 用错了比不用还危险。本篇通过可运行实验，让你直观感受 atomic 和 mutex 的性能差异，明确 atomic 的"可用边界"——它只适合单变量原子性。

### 第 27 篇：io.Reader/Writer 流式处理
一次 OOM 让我重新认识了 io.Reader：流式处理的正确姿势。本篇通过 5 个示例展示 io.Copy、io.TeeReader、io.LimitReader、io.MultiWriter、io.Pipe 的用法，告别 ReadAll，掌握流式思维。

### 第 28 篇：Bufio 性能优化
同样的代码，为什么他的比我快 10 倍？bufio 的秘密。本篇通过 4 组对比实验，让你直观感受"加一层 buffer"带来的性能差异，理解系统调用成本。

### 第 29 篇：JSON 配置加载实战
一个拼写错误让我排查了三小时：JSON 配置的正确打开方式。本篇展示"两层结构体"设计、DisallowUnknownFields 严格解码、UseNumber 避免精度丢失，让 JSON 配置不再"静默失败"。

### 第 30 篇：HTTP 客户端最佳实践
一次请求卡死让我重写了所有 HTTP 调用。本篇通过模拟快/慢响应，展示全局超时和请求级超时的差异，讲解 HTTP 客户端的正确配置方式。

### 第 31 篇：标准库 HTTP 服务端
用标准库写 HTTP API，我再也不想依赖框架了。本篇展示如何用中间件链、ServeMux、httptest 构建清晰可维护的 API，包括严格 JSON 校验等实战技巧。

### 第 32 篇：Context + HTTP 实战
请求超时不生效？你可能没搞懂 Context 的正确用法。本篇展示如何用 context.WithTimeout 在中间件层统一设置超时，用 context.WithValue 注入 request id 实现全链路追踪，让整个调用链都"听"Context 的话。

### 第 33 篇：配置管理工程化
配置没生效？你可能搞错了 flag/env/config 的优先级。本篇建立明确的配置合并顺序（默认值 < 配置文件 < 环境变量 < flag），用指针字段区分"没写"和"写了零值"，实现可追溯的配置管理。

### 第 34 篇：Go 测试实战
测试不是形式主义：聊聊 Go 测试如何成为你的开发护栏。本篇讲解表驱动测试、t.Run 子测试、t.Parallel 并行加速、errors.Is 错误断言、t.Helper 自定义断言，让测试成为重构的安全网。

### 第 35 篇：基准测试实战
你的 benchmark 可能测了个寂寞。本篇讲解 b.ResetTimer 排除初始化开销、sink 变量防止编译器优化、-benchmem 关注内存分配、b.Run 多方案对比等基准测试的正确姿势。

### 第 36 篇：Race Detector 实战
线上计数总是少几个？一个命令帮你揪出并发 Bug。本篇通过最小化计数器示例，演示如何用 Go 的 race detector 把隐藏的数据竞争暴露出来。

### 第 37 篇：Pprof 性能分析
接口慢了 3 秒，我是怎么用 pprof 找到元凶的。本篇演示如何用 Go 内置的 pprof 工具生成 CPU 和内存 profile 文件，让性能问题"有据可查"。

### 第 38 篇：项目结构进阶
项目越写越乱？聊聊 Go 的 cmd 和 internal 到底怎么用。本篇演示 cmd 和 internal 的正确用法——它们不是摆设，而是约束依赖方向的工具。

### 第 39 篇：错误设计与结构化日志
线上出 Bug 没线索？聊聊 Go 的错误设计和结构化日志。本篇演示如何设计一套"可观测"的错误和日志体系——错误可分类、可追溯，日志结构化、可检索。

### 第 40 篇：综合实战项目
代码能跑但不敢改？聊聊从"会写 Go"到"写好 Go"。本篇是"毕业设计"，把结构、错误、并发、配置、日志这些工程能力串成一套完整的任务执行器实践。
