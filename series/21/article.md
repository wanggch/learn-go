# channel 的本质：通信 vs 同步

你好，我是汪小成。你有没有写过这样的并发代码：为了“线程安全”把所有共享数据都丢进 channel，结果程序越来越绕；或者反过来，完全不用 channel，只靠锁，最后业务变成一堆临界区。channel 在 Go 里很重要，但它的本质不是“替代锁”，而是提供一种**可组合的通信机制**：既能传递数据（通信），也能建立阻塞点（同步）。把用途分清后，很多并发设计会更清晰：无缓冲 channel 做握手，有缓冲 channel 做队列，close 广播结束信号，channel 充当信号量限制并发。本文会按这个框架走一遍，并给出可运行示例。

## 目录

1. 环境准备 / 前提知识  
2. 核心概念解释（概念 → 示例 → 为什么这么设计）  
3. 完整代码示例（可运行）  
4. 运行效果 + 截图描述  
5. 常见坑 & 解决方案（必写）  
6. 进阶扩展 / 思考题  

## 1. 环境准备 / 前提知识

### 1.1 版本与目录

- Go 1.22+（仓库根目录使用 `go.work`）。
- 本篇目录：`series/21`。
- 示例入口：`series/21/cmd/chanlab/main.go`。

### 1.2 运行命令

```bash
go run ./series/21/cmd/chanlab -items=6 -buffer=2 -prod=10ms -cons=25ms -workers=2 -sem=2
```

沙盒环境若遇到构建缓存权限问题，使用：

```bash
GOCACHE=$(pwd)/.cache/go-build go run ./series/21/cmd/chanlab -items=6 -buffer=2 -prod=10ms -cons=25ms -workers=2 -sem=2
```

### 1.3 前置知识

- goroutine 基础（第 19 篇）。
- 对 `select` 不熟也没关系，本篇示例不依赖复杂 select（下一篇会更深入）。

配图建议：
- 一张“通信 vs 同步”对照图（channel 传数据、channel 作为阻塞点）。
- 一张“无缓冲握手 vs 有缓冲队列”对比图。

## 2. 核心概念解释（概念 → 示例 → 为什么这么设计）

### 2.1 channel 是什么：类型安全的通信管道

**概念**：channel 是一个类型安全的管道，发送端用 `<-` 发送值，接收端用 `<-` 接收值。  
**示例**：`ch := make(chan int)`，`ch <- 1`，`v := <-ch`。  
**为什么这么设计**：让并发程序在“数据流动”这件事上有明确的结构：谁产出、谁消费、什么时候结束。

更重要的是，channel 的阻塞语义是可预测的：当无法发送/无法接收时，goroutine 会阻塞。这种阻塞既可以用来实现通信，也可以用来实现同步。

### 2.2 通信 vs 同步：不要把用途混在一起

你可以把 channel 的用途分成两类：

1. **通信（data passing）**：把数据从 A 传到 B。典型例子：生产者-消费者队列、流水线阶段之间传递消息。
2. **同步（coordination）**：不关心数据本身，只利用“阻塞/解除阻塞”来协调时序。典型例子：信号量（限制并发）、done 信号（通知退出）、一次性握手。

为什么要分清：用途混乱会让代码充满“无意义 token”和绕路逻辑，难读难测。

### 2.3 无缓冲 channel：发送与接收是同一个同步点

**概念**：无缓冲 channel（unbuffered）发送会阻塞直到有人接收；接收会阻塞直到有人发送。  
**示例**：一个 goroutine `ch <- "A"`，另一个 goroutine 40ms 后再 `<-ch`，你会看到发送在 40ms 前一直卡住。  
**为什么这么设计**：这就是天然的“握手”（handshake）。当你需要“发送方必须确定接收方已接到”时，无缓冲很合适。

工程上常见的用法：

- 把无缓冲 channel 当“确认点”：A 发出信号后必须等 B 接收，才继续后续步骤。
- 把它当“同步门闩”：某一步必须等另一步到达后再放行。

### 2.4 有缓冲 channel：把通信队列化

**概念**：有缓冲 channel（buffered）允许在容量范围内“先放进去再说”。当缓冲满了，发送才会阻塞；当缓冲空了，接收才会阻塞。  
**示例**：producer 以 10ms 速度发送，consumer 以 25ms 速度消费，buffer=2 时你会看到 `len(ch)` 有时到 2，意味着队列堆积。  
**为什么这么设计**：它是一个非常轻量的队列模型，用来在短时间内平滑生产/消费速率差异。

工程建议：buffer 只覆盖小波动即可，过大只会把问题“藏进队列”，增加延迟与内存。

### 2.5 close：广播“不会再有新数据”

**概念**：close channel 的含义是：不会再有新的发送。接收端可以用：

- `for v := range ch` 自动读到 close 为止  
- `v, ok := <-ch` 判断 `ok` 是否为 false  

**为什么这么设计**：让“结束”成为一等事件，接收方不需要额外的“结束标记值”。close 还有广播语义：多个接收者都能感知到结束。

关键原则：**只有发送方关闭 channel**（接收方不知道是否还有别的发送者）。

### 2.6 channel 当信号量：同步用途的经典写法

**概念**：把 `chan struct{}` 的容量当作并发上限。发送 token 表示占用，接收 token 表示释放。  
**示例**：`sem := make(chan struct{}, 2)`，启动 5 个任务，但同一时刻只有 2 个在执行。  
**为什么这么设计**：信号量写法非常轻量，读起来也直观，而且不会引入共享状态的锁竞争（它本质是同步协调）。

配图建议：
- 一张“无缓冲握手时间线”（sender 卡住 → receiver 读 → 两边继续）。
- 一张“有缓冲队列”图（len/cap 的堆积与背压）。
- 一张“close 广播”图（多个 worker range 退出）。

## 3. 完整代码示例（可运行）

示例包含 4 个部分：

1. 无缓冲 channel 的握手同步  
2. 有缓冲 channel 的生产者-消费者队列  
3. close 与 ok 形式读取（结束广播）  
4. channel 作为信号量限制并发  

代码路径：`series/21/cmd/chanlab/main.go`（可直接运行，参数可调）。

## 4. 运行效果 + 截图描述

运行：

```bash
go run ./series/21/cmd/chanlab -items=6 -buffer=2 -prod=10ms -cons=25ms -workers=2 -sem=2
```

你会看到四段输出，最关键的观察点是：

- **无缓冲握手**：sender 在 receiver 接收前一直不“已发送”，证明发送=同步点。
- **有缓冲队列**：`len(ch)` 会达到 `cap(ch)`，说明 producer 被背压阻塞。
- **close 广播**：多个 worker 会打印 `jobs closed` 并退出。
- **信号量限制并发**：`inflight` 不会超过 `sem` 指定的上限。

截图建议：
- 握手时间戳对比 + 有缓冲 len/cap 达到 cap 的瞬间。
- close 后多个 worker 退出 + 信号量 inflight 上限效果。

## 5. 常见坑 & 解决方案（必写）

1. **忘记接收导致死锁**：无缓冲发送没人接收会永远卡住。解决：确保有接收者；必要时用超时兜底。
2. **把 channel 当“万能锁”**：所有共享状态都改成 channel 串行处理，导致代码绕、吞吐低。解决：小范围用 Mutex/atomic；需要结构化通信时再用 channel。
3. **发送到已关闭 channel**：会 panic。解决：约定“只有发送方关闭”，并在设计上保证 close 只发生一次。
4. **从 nil channel 读写**：会永久阻塞。解决：初始化 channel，并在接口边界做非 nil 校验。
5. **缓冲设置过大**：表面上不阻塞了，但延迟与内存不可控，问题被“藏在队列里”。解决：小缓冲+有界并发+限流，必要时记录队列长度指标。
6. **用特殊值当结束标记**：比如发送 `-1` 表示结束，遇到真实数据冲突。解决：用 close 广播结束，或者用单独的 done channel。
7. **多生产者乱关 channel**：任意一个生产者 close 导致其他发送 panic。解决：集中关闭（一个协调者/WaitGroup 计数归零后关闭）。
8. **range 消费者没退出条件**：忘记 close，消费者永远阻塞。解决：明确关闭时机，或增加 ctx/done 信号。

配图建议：
- “谁关闭 channel”决策图（单生产者 vs 多生产者）。

## 6. 进阶扩展 / 思考题

- 把示例 2 改成多生产者：用 WaitGroup 等所有生产者结束后统一 close，避免 panic。
- 把 `sem` 限流改成 worker pool：任务 channel + N 个 worker，比较两种实现的可读性与扩展性。
- 思考题：在你的项目里，哪些场景是“通信为主”，哪些是“同步为主”？你能否减少“无意义 token”的 channel 使用？
---

channel 既能传数据（通信），也能用阻塞语义协调时序（同步）。无缓冲适合握手，有缓冲适合队列，close 广播结束信号，`chan struct{}` 常用作信号量限制并发。
