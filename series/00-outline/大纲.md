# Go 语言系统学习系列大纲（40 篇完整版）

> 读者：有编程经验但未系统学过 Go。每篇都有可运行代码与工程产出。

## 第一阶段：进入 Go 的世界（1–6）

1. **我为什么最终选择 Go，而不是 Java / Python**
   - 收益：理解 Go 的设计目标与适用边界。
   - 核心点：编译速度、部署方式、并发模型、生态定位。
   - 示例：第一个可执行 Go 程序。

2. **从 `main` 开始：Go 程序是怎么跑起来的**
   - 收益：掌握最小可用 CLI 的结构。
   - 核心点：package/main、编译流程、参数解析。
   - 示例：带参数的 CLI。

3. **一个目录 = 一个包：Go 项目结构到底该怎么摆**
   - 收益：明确包边界与可见性规则。
   - 核心点：包名、导出规则、internal。
   - 示例：拆分 package 的小项目。

4. **变量、类型与零值：Go 如何减少未定义行为**
   - 收益：掌握零值策略与初始化方式。
   - 核心点：零值哲学、结构体初始化。
   - 示例：配置结构体初始化示例。

5. **if / for / switch：写出“Go 味”的控制流**
   - 收益：掌握简洁但克制的控制流写法。
   - 核心点：短变量声明、switch 设计。
   - 示例：参数校验工具。

6. **slice 和 map：90% Bug 都藏在这里**
   - 收益：理解 len/cap 与扩容。
   - 核心点：append、复制、map 读取。
   - 示例：slice 扩容实验程序。

## 第二阶段：组织代码的能力（7–12）

7. **函数与多返回值：Go 是如何对待错误的**
   - 收益：理解 error 风格与边界。
   - 核心点：多返回值、errors 包。
   - 示例：文件读取工具。

8. **struct 与方法：Go 的“面向对象”实践**
   - 收益：掌握值/指针接收者。
   - 核心点：方法集、结构体组合。
   - 示例：领域模型 + 方法集。

9. **interface：隐式实现到底解决了什么问题**
   - 收益：理解接口隔离与抽象。
   - 核心点：最小接口、依赖反转。
   - 示例：可替换存储接口。

10. **interface + nil：Go 初学者第一大坑**
    - 收益：避免 nil 判断误区。
    - 核心点：动态类型 vs 动态值。
    - 示例：nil 判断实验程序。

11. **defer、panic、recover：异常不是你想的那样**
    - 收益：掌握资源释放与崩溃恢复。
    - 核心点：defer 顺序、panic 语义。
    - 示例：安全执行器。

12. **组合优于继承：Go 的设计思维**
    - 收益：掌握组合式复用。
    - 核心点：嵌入、行为复用。
    - 示例：组合结构体示例。

## 第三阶段：内存、指针与逃逸（13–18）

13. **指针不是洪水猛兽：什么时候你必须用指针**
    - 收益：理解拷贝成本与修改语义。
    - 核心点：值/指针传参。
    - 示例：指针 vs 值对比程序。

14. **栈还是堆？变量是怎么“逃逸”的**
    - 收益：读懂逃逸分析输出。
    - 核心点：`-gcflags=-m`。
    - 示例：逃逸分析实验。

15. **GC 到底什么时候跑？会卡住程序吗**
    - 收益：理解 STW 与 GC 时机。
    - 核心点：GOGC、STW。
    - 示例：内存分配实验。

16. **减少分配：写出对 GC 友好的 Go 代码**
    - 收益：掌握对象复用策略。
    - 核心点：复用、池化。
    - 示例：优化前后 benchmark。

17. **string / []byte / rune：编码与性能的真相**
    - 收益：理解不可变与编码成本。
    - 核心点：UTF-8、rune。
    - 示例：字符串处理工具。

18. **time 包：时间是最难的工程问题之一**
    - 收益：掌握时区与定时器。
    - 核心点：Timer/Ticker。
    - 示例：定时任务程序。

## 第四阶段：并发的真正用法（19–26）

19. **goroutine：并发不是免费的午餐**
    - 收益：理解调度与成本。
    - 核心点：调度模型。
    - 示例：并发任务执行器。

20. **WaitGroup 与 Mutex：共享数据的正确方式**
    - 收益：避免竞态问题。
    - 核心点：互斥与等待。
    - 示例：并发计数器。

21. **channel 的本质：通信 vs 同步**
    - 收益：掌握阻塞语义。
    - 核心点：缓冲/非缓冲。
    - 示例：生产者-消费者模型。

22. **select：写出不会死锁的并发代码**
    - 收益：掌握超时控制。
    - 核心点：多路复用。
    - 示例：超时控制模型。

23. **goroutine 泄漏：它们去哪了？**
    - 收益：识别与修复泄漏。
    - 核心点：退出条件。
    - 示例：泄漏示例 + 修复。

24. **context：并发世界的“取消协议”**
    - 收益：掌握取消与超时传播。
    - 核心点：传播链路。
    - 示例：可取消任务池。

25. **并发模式总结：worker pool、fan-in/out**
    - 收益：选择合适模式。
    - 核心点：模式对比。
    - 示例：并发下载器。

26. **atomic 与 lock-free 的使用边界**
    - 收益：理解原子操作适用场景。
    - 核心点：原子与锁的权衡。
    - 示例：原子计数器。

## 第五阶段：标准库即战力（27–33）

27. **文件与 IO：io.Reader / Writer 的威力**
    - 收益：理解接口抽象。
    - 核心点：Reader/Writer。
    - 示例：文件复制工具。

28. **bufio：为什么加一层 buffer 差这么多**
    - 收益：理解系统调用成本。
    - 核心点：缓冲 IO。
    - 示例：性能对比程序。

29. **encoding/json：最熟悉也是坑最多的包**
    - 收益：掌握 tag 与零值。
    - 核心点：编码/解码。
    - 示例：配置加载器。

30. **net/http（客户端）：你每天都在用却没用好**
    - 收益：掌握超时与连接复用。
    - 核心点：Client/Transport。
    - 示例：HTTP 请求库。

31. **net/http（服务端）：用标准库写一个 API**
    - 收益：掌握 handler 与中间件。
    - 核心点：路由、状态码。
    - 示例：REST API 服务。

32. **context + HTTP：请求生命周期管理**
    - 收益：掌握超时与取消。
    - 核心点：Context。
    - 示例：可取消 API。

33. **flag / env / config：配置是工程问题**
    - 收益：理解配置优先级。
    - 核心点：flag/env/config。
    - 示例：完整 CLI 工具。

## 第六阶段：质量、调试与性能（34–40）

34. **go test：把测试当开发工具**
    - 收益：掌握表驱动与子测试。
    - 核心点：测试结构。
    - 示例：表驱动测试。

35. **benchmark：你测的真的是性能吗**
    - 收益：理解基准测试边界。
    - 核心点：allocs/op。
    - 示例：基准测试对比。

36. **race detector：并发 bug 的照妖镜**
    - 收益：定位竞态条件。
    - 核心点：-race。
    - 示例：竞态示例。

37. **pprof：性能问题从哪里下手**
    - 收益：读懂火焰图。
    - 核心点：CPU/内存剖析。
    - 示例：性能剖析示例。

38. **项目结构与依赖：internal / cmd 的真正用途**
    - 收益：理解包边界与依赖方向。
    - 核心点：internal/cmd。
    - 示例：重构已有项目。

39. **错误、日志与可观测性设计**
    - 收益：构建可诊断系统。
    - 核心点：错误包装、日志结构化。
    - 示例：统一错误与日志方案。

40. **从“会写 Go”到“写好 Go”**
    - 收益：建立长期工程能力。
    - 核心点：习惯与路线。
    - 示例：完整项目复盘。