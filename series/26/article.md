# atomic 与 lock-free：使用边界在哪里

你好，我是汪小成。你可能听过这样的说法：“原子操作比锁快，所以尽量用 atomic。”于是你把所有计数器、状态位都改成 atomic，结果代码越来越难懂，bug 反而更多：统计指标出现“半更新”，配置状态读到一半，甚至在非原子字段上踩了 data race。`sync/atomic` 的确是高效工具，但它解决的是**非常局部、非常明确的并发问题**。一旦你跨字段、跨步骤、跨不变量，锁反而更稳。本文会用一个可运行实验对比 atomic 和 mutex 的成本，并明确原子操作的“可用边界”和“不可用边界”。

## 目录

1. 环境准备 / 前提知识  
2. 核心概念解释（概念 → 示例 → 为什么这么设计）  
3. 完整代码示例（可运行）  
4. 运行效果 + 截图描述  
5. 常见坑 & 解决方案（必写）  
6. 进阶扩展 / 思考题  

## 1. 环境准备 / 前提知识

### 1.1 版本与目录

- Go 1.22+（仓库根目录使用 `go.work`）。
- 本篇目录：`series/26`。
- 示例入口：`series/26/cmd/atomiclab/main.go`。

### 1.2 运行命令

```bash
go run ./series/26/cmd/atomiclab -workers=40 -loops=50000
```

沙盒环境若遇到构建缓存权限问题，使用：

```bash
GOCACHE=$(pwd)/.cache/go-build go run ./series/26/cmd/atomiclab -workers=40 -loops=50000
```

### 1.3 前置知识

- Mutex/WaitGroup 的用途（第 20 篇）。
- 并发与 goroutine 的基本概念（第 19 篇）。

配图建议：
- 一张“atomic vs mutex 使用边界”对比表（单字段计数 vs 多字段一致性）。
- 一张“多字段一致性破裂”示意图（读到半更新）。

## 2. 核心概念解释（概念 → 示例 → 为什么这么设计）

### 2.1 atomic 解决的是“单变量”的原子性

**概念**：atomic 的基本语义是“对某个变量的读/改/写是不可分割的”。  
**示例**：`atomic.AddInt64(&counter, 1)` 保证计数器不会丢。  
**为什么这么设计**：原子操作能避免锁的上下文切换成本，适合极高频的单值更新。

但请注意：atomic 并不保证“多变量之间的一致性”。你可以原子地更新 A 和 B，但 **无法保证“某个时刻读到的 A 与 B 是同一次更新”**。

### 2.2 mutex 解决的是“临界区”的一致性

**概念**：mutex 把一段代码变成“同一时刻只能一个 goroutine 进入”。  
**示例**：把 `counter++` 放进锁里，所有更新串行化。  
**为什么这么设计**：当你的逻辑包含多个字段、多个步骤、或需要保持不变量时，锁能保证一致性。

atomic 更像“高速公路”，mutex 更像“红绿灯”。该快的时候快，该稳的时候稳。

### 2.3 lock-free ≠ 无脑高性能

“lock-free”经常被误解成“更快”。现实中，lock-free 算法非常难写，容易出错，测试成本高。  
对于大多数业务代码：**“可读 + 可证正确” 比 “理论极限性能” 更重要**。  
工程上，你应该优先用 Mutex 或 channel；只有当 profiling 显示锁争用是瓶颈，且问题足够局部，才考虑 atomic 或 lock-free 技术。

### 2.4 原子 + 结构体：快但不可一致

例如一个统计结构：

```
requests, errors, latency_sum
```

你可以对每个字段用 atomic.Add，但当你要输出一个“某时刻的完整统计快照”，你会发现无法保证它们来自同一时刻。这就是“原子快照缺失”的典型问题。  
如果你真的需要一致快照，通常要：

- 用 Mutex 保护读取和写入  
- 或者用 copy-on-write / swap（更复杂）

### 2.5 正确的边界：atomic 适合“计数器/状态位/指针交换”

原子操作最适合的场景：

- 计数器（QPS、请求数）
- 状态位（是否关闭、是否初始化）
- 指针/引用交换（atomic.Value 或 CAS 模式）

不适合的场景：

- 多字段一致性  
- 复杂业务不变量（如余额=入账-出账必须一致）  
- 需要可读性/可测试性的复杂逻辑  

配图建议：
- 一张“适合 atomic vs 不适合 atomic”的清单图。
- 一张“状态位/计数器/指针交换”示意。

## 3. 完整代码示例（可运行）

示例包含三部分：

1. atomic 计数器  
2. mutex 计数器  
3. atomic 多字段统计（展示“无一致快照”的边界）  

代码路径：`series/26/cmd/atomiclab/main.go`。

## 4. 运行效果 + 截图描述

运行：

```bash
go run ./series/26/cmd/atomiclab -workers=40 -loops=50000
```

典型输出（节选）：

```
--- atomic counter ---
counter=2000000 expected=2000000 cost=49ms...

--- mutex counter ---
counter=2000000 expected=2000000 cost=128ms...

--- atomic stats (multi-field boundary) ---
requests=2000000 errors=200000 latency_sum=5999880 cost=87ms...
注意：多字段统计没有“原子快照”，若需要一致性应使用锁或拷贝策略。
```

截图建议（每 500 字 1~2 张）：

- 截图 1：atomic vs mutex 的耗时对比（强调“单字段计数器 atomic 更快”）。
- 截图 2：多字段统计输出（强调“无一致快照”）。
- 截图 3：一张“边界提示图”（适用/不适用列表）。

## 5. 常见坑 & 解决方案（必写）

1. **把 atomic 当“万能锁”**：多字段一致性被破坏。解决：跨字段逻辑用锁或复制策略。
2. **只改写一处，其他读写仍非原子**：造成 data race。解决：同一变量的读写要统一走 atomic.Load/Store/Add。
3. **忽视内存对齐与类型**：原子操作只对特定类型安全（int32/int64 等），误用会 panic 或错误。解决：使用 `sync/atomic` 提供的类型/函数，避免手写不安全。
4. **误读“快”**：atomic 虽快但不是零成本，尤其在高争用下仍有性能瓶颈。解决：用基准测试验证，必要时用分片计数（sharding）。
5. **用 atomic 实现复杂状态机**：CAS 重试导致代码难读且易错。解决：用 mutex 或 channel，把复杂逻辑放到单线程事件循环里。
6. **把 atomic.Value 当全局缓存**：更新频率高导致频繁分配。解决：atomic.Value 适合低频写、高频读场景；高频写建议锁或分片。
7. **忽略可测试性**：原子逻辑难覆盖，错误隐蔽。解决：把 atomic 封装成小函数，提供单测与替身。
8. **错误的优化顺序**：先上 atomic，再找问题。解决：先做 profiling，锁争用确实是瓶颈再优化。

配图建议：
- “atomic 滥用”反例图（多字段一致性破裂）。
- “分片计数器”示意（多个局部计数器 + 汇总）。

## 6. 进阶扩展 / 思考题

- 写一个分片计数器：`N` 个 atomic 计数器 + hash 分配，再定期汇总，比较与单一 atomic 的吞吐与一致性。
- 用 `atomic.Value` 做配置热更新：低频写、高频读，观察与 mutex 的差异。
- 尝试用 CAS 实现一个无锁栈（仅学习），体会复杂度与正确性成本。
- 思考题：在你的业务里，哪些指标适合“近似一致”（atomic），哪些必须“强一致”（mutex/事务）？
- 思考题：如果 atomic 让代码变复杂但性能提升只有 5%，你会选哪个？为什么？

---

atomic 不是银弹，它适合“单字段、高频、低延迟”的场景；mutex 适合“多字段一致性、复杂逻辑”的场景。真正的工程判断是：先确保正确性，再用 profiling 决定是否要用 atomic；如果 atomic 让代码难以维护，收益又有限，就不要勉强。把边界想清楚，你就能把“快”和“稳”同时兼顾。
